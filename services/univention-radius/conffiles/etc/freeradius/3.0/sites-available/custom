server custom {
	listen {
		type = auth
		ipaddr = *
		port = 0
		limit {
			#
			#  Limit the number of simultaneous TCP connections to the socket
			#
			#  The default is 16.
			#  Setting this to 0 means "no limit"

			max_connections = 16

			#  The per-socket "max_requests" option does not exist.
			#
			#  The lifetime, in seconds, of a TCP connection.  After
			#  this lifetime, the connection will be closed.
			#
			#  Setting this to 0 means "forever".

			lifetime = 0

			#
			#  The idle timeout, in seconds, of a TCP connection.
			#  If no packets have been received over the connection for
			#  this time, the connection will be closed.
			#
			#  Setting this to 0 means "no timeout".
			#
			#  We STRONGLY RECOMMEND that you set an idle timeout.
			#

			idle_timeout = 30
		}
	}
	listen {
		ipaddr = *
		port = 0
		type = acct
	}

	# IPv6 versions of the above - read their full config to understand options
	listen {
		type = auth
		ipv6addr = ::	# any.  ::1 == localhost
		port = 0

		limit {
		      max_connections = 16
		      lifetime = 0
		      idle_timeout = 30
		}
	}

	listen {
		ipv6addr = ::
		port = 0
		type = acct
	}

	authorize {
		#
		#  Take a User-Name, and perform some checks on it, for spaces and other
		#  invalid characters.  If the User-Name appears invalid, reject the
		#  request.
		#
		#  See policy.d/filter for the definition of the filter_username policy.
		#
		filter_username
		#
		#  The preprocess module takes care of sanitizing some bizarre
		#  attributes in the request, and turning them into attributes
		#  which are more standard.
		#
		#  It takes care of processing the 'raddb/hints' and the
		#  'raddb/huntgroups' files.
		preprocess
		## According to RFC 3580 should sanitize the MAC address to "AA-BB-CC-DD-EE-FF"
		## see https://tools.ietf.org/html/rfc3580 3.20 & 3.21
		## see also https://wiki.freeradius.org/guide/mac-auth
		## This can be achieved by using these functions defined in /etc/freeradius/../policy.d/canonicalization:
		## rewrite_called_station_id   # For the NAS/WLAN-AP
		## rewrite_calling_station_id  # For the Client
		## Unfortunately, OpenLDAP stores the macAddress as "aa:bb:cc:dd:ee:ff" (lowercase and ':' instead of '-')
		## Therefore we adapt 'rewrite_calling_station_id' to fit our needs:
		if (Calling-Station-Id =~ /([0-9a-f]{2})[-:]?([0-9a-f]{2})[-:.]?([0-9a-f]{2})[-:]?([0-9a-f]{2})[-:.]?([0-9a-f]{2})[-:]?([0-9a-f]{2})/i) {
			update request {
				Calling-Station-Id := "%{tolower:%{1}:%{2}:%{3}:%{4}:%{5}:%{6}}"
			}
		}
	    ## To handle unauthenticated clients based on their MAC address, we check IF we are talking EAP or not:
		if (!&EAP-Message) {
            # Scenario: known client, but client can't be authenticated via EAP + MSCHAPv2 (not joined (yet), PXE-Boot etc.)
            # So we are not talking EAP. Therefore we do check the MAC address and the VLAN-ID:
            if ("%{ldap:ldap:///@%@ldap/base@%@?VlanId?sub?(macAddress=%{Calling-Station-Id})}") {
                update control {
                    Auth-Type := Accept
                }
                update reply {
                    Reply-Message := "DEBUG: Non-EAP: MAC found, VLAN ID found - sending VLAN-ID from LDAP object"
                    Tunnel-Type := VLAN
                    Tunnel-Medium-Type := IEEE-802
                    Tunnel-Private-Group-Id := "%{ldap:ldap:///@%@ldap/base@%@?VlanId?sub?(macAddress=%{Calling-Station-Id})}"
                }
            }
            ## If we can only find the macAddress but no VLAN ID, send the client to the default VLAN:
            elsif ("%{ldap:ldap:///@%@ldap/base@%@?macAddress?sub?(macAddress=%{Calling-Station-Id})}") {
                # accept and send default VLAN ID:
                update control {
                    Auth-Type := Accept
                }
                update reply {
                    Reply-Message := "DEBUG: Non-EAP: MAC found, but no VLAN ID - sending default VLAN-ID"
                    Tunnel-Type := VLAN
                    Tunnel-Medium-Type := IEEE-802
                    Tunnel-Private-Group-Id := "@%@freeradius/conf/vlan/vlan-id@%@"
                }
                return
            }
            ## FIXME: isn't here an else missing with update_control { Auth-Type := Reject} or is this BYOD ?
		}
		## IF we are talking EAP, follow the default auth config:
		else {
			#
			#  The chap module will set 'Auth-Type := CHAP' if we are
			#  handling a CHAP request and Auth-Type has not already been set
			chap
			#
			#  If the users are logging in with an MS-CHAP-Challenge
			#  attribute for authentication, the mschap module will find
			#  the MS-CHAP-Challenge attribute, and add 'Auth-Type := MS-CHAP'
			#  to the request, which will cause the server to then use
			#  the mschap module for authentication.
			mschap
			#
			#  If you are using multiple kinds of realms, you probably
			#  want to set "ignore_null = yes" for all of them.
			#  Otherwise, when the first style of realm doesn't match,
			#  the other styles won't be checked.
			ntdomain
			#
			#  This module takes care of EAP-MD5, EAP-TLS, and EAP-LEAP
			#  authentication.
			#
			#  It also sets the EAP-Type attribute in the request
			#  attribute list to the EAP type from the packet.
			#
			#  As of 2.0, the EAP module returns "ok" in the authorize stage
			#  for TTLS and PEAP.  In 1.x, it never returned "ok" here, so
			#  this change is compatible with older configurations.
			#
			#  The example below uses module failover to avoid querying all
			#  of the following modules if the EAP module returns "ok".
			#  Therefore, your LDAP and/or SQL servers will not be queried
			#  for the many packets that go back and forth to set up TTLS
			#  or PEAP.  The load on those servers will therefore be reduced.
			#
			eap {
				ok = return
			}
			#
			#  Read the 'users' file
			files
			#
			#  The ldap module will set Auth-Type to LDAP if it has not
			#  already been set
			ldap
			expiration
			logintime
			#
			#  If no other module has claimed responsibility for
			#  authentication, then try to use PAP.  This allows the
			#  other modules listed above to add a "known good" password
			#  to the request, and to do nothing else.  The PAP module
			#  will then see that password, and use it to do PAP
			#  authentication.
			#
			#  This module should be listed last, so that the other modules
			#  get a chance to set Auth-Type for themselves.
			#
			pap
		}
	}
	#  Authentication.
	#
	#
	#  This section lists which modules are available for authentication.
	#  Note that it does NOT mean 'try each module in order'.  It means
	#  that a module from the 'authorize' section adds a configuration
	#  attribute 'Auth-Type := FOO'.  That authentication type is then
	#  used to pick the apropriate module from the list below.
	#
	#  In general, you SHOULD NOT set the Auth-Type attribute.  The server
	#  will figure it out on its own, and will do the right thing.  The
	#  most common side effect of erroneously setting the Auth-Type
	#  attribute is that one authentication method will work, but the
	#  others will not.
	#
	#  The common reasons to set the Auth-Type attribute by hand
	#  is to either forcibly reject the user (Auth-Type := Reject),
	#  or to or forcibly accept the user (Auth-Type := Accept).
	#
	#  Note that Auth-Type := Accept will NOT work with EAP.
	#
	#  Please do not put "unlang" configurations into the "authenticate"
	#  section.  Put them in the "post-auth" section instead.  That's what
	#  the post-auth section is for.
	#
	authenticate {
		#
		#  PAP authentication, when a back-end database listed
		#  in the 'authorize' section supplies a password.  The
		#  password can be clear-text, or encrypted.
		Auth-Type PAP {
			pap
		}
		#
		#  Most people want CHAP authentication
		#  A back-end database listed in the 'authorize' section
		#  MUST supply a CLEAR TEXT password.  Encrypted passwords
		#  won't work.
		Auth-Type CHAP {
			chap
		}
		#
		#  MSCHAP authentication.
		Auth-Type MS-CHAP {
			mschap
		}
		#
		#  See 'man getpwent' for information on how the 'unix'
		#  module checks the users password.  Note that packets
		#  containing CHAP-Password attributes CANNOT be authenticated
		#  against /etc/passwd!  See the FAQ for details.
		#
		# unix
		# Uncomment it if you want to use ldap for authentication
		#
		# Note that this means "check plain-text password against
		# the ldap database", which means that EAP won't work,
		# as it does not supply a plain-text password.
		Auth-Type LDAP {
			ldap
		}
		#
		#  Allow EAP authentication.
		eap
	}
	#
	#  Pre-accounting.  Decide which accounting type to use.
	#
	preacct {
		preprocess
		#  Ensure that we have a semi-unique identifier for every
		#  request, and many NAS boxes are broken.
		acct_unique
		# Setting suffix as realm default MSCHAP needs ntdomain
		ntdomain
		#
		#  Read the 'acct_users' file
		files
	}
	#
	#  Accounting.  Log the accounting data.
	#
	accounting {
		#
		#  Create a 'detail'ed log of the packets.
		#  Note that accounting requests which are proxied
		#  are also logged in the detail file.
		detail
		#
		#  For Simultaneous-Use tracking.
		#
		#  Due to packet losses in the network, the data here
		#  may be incorrect.  There is little we can do about it.
	#	 radutmp
		#  Filter attributes from the accounting response.
		attr_filter.accounting_response
	}
	#  Session database, used for checking Simultaneous-Use. Either the radutmp
	#  or rlm_sql module can handle this.
	#  The rlm_sql module is *much* faster
	session {
	#	radutmp
	}
	#  Post-Authentication
	#  Once we KNOW that the user has been authenticated, there are
	#  additional steps we can take.
	post-auth {
		# Load module: ldap
		ldap
		# Rewrite username if it is a machine account:
		if ("%{request:User-Name}" =~ /^host\/(.*)@%@ldap/base@%@$/) {
			update request {
				User-Name := "%{1}$"    #FIXME Why is the host name overwriting the User-Name and why a trailing dollar sign???
			}
		}
		# Check if the user exists (and is not a macAddress) and do post-auth actions
		# else do nothing in post-auth
		# This way we also make sure that we do not change the VLAN ID again if the non-EAP-auth (MAC address auth) succeeded before (see above)
		if ("%{ldap:ldap:///@%@ldap/base@%@?vlan-ID?sub?(uid=%{User-Name})}") {
			# We now assume that we have a user or machine account that has been authenticated via username+password
			# First check for known computer objects (= have a macAddress) and the corresponding VLAN ID
			# Scenario: Known client, client has been authenticated via EAP + MSCHAPv2
			# We only check for VLANs that are trusted networks (no BYOD). The most common cases are checked first.
			if ("%{ldap:ldap:///@%@ldap/base@%@?VlanId?sub?(&(uid=%{User-Name})(macAddress=*))}") {
				update reply {
					Reply-Message := "DEBUG: Assigning VLAN-ID from computer object"
					Tunnel-Type := VLAN
					Tunnel-Medium-Type := IEEE-802
					Tunnel-Private-Group-Id := "%{ldap:ldap:///@%@ldap/base@%@?VlanId?sub?(&(uid=%{User-Name})(macAddress=*))}"
				}
			}
			# If we can not find a known computer object, we look for VLAN IDs at the user object.
			# Scenario: Known user, unknown client, user has been authenticated via EAP + MSCHAPv2
			elsif ("%{ldap:ldap:///@%@ldap/base@%@?VlanId?sub?(&(uid=%{User-Name})(objectClass=inetOrgPerson))}") {  #FIXME: is the objectclass correct?
				update reply {
					Reply-Message := "DEBUG: Assigning VLAN-ID from user object"
					Tunnel-Type := VLAN
					Tunnel-Medium-Type := IEEE-802
					Tunnel-Private-Group-Id := "%{ldap:ldap:///@%@ldap/base@%@?VlanId?sub?(&(uid=%{User-Name})(objectClass=inetOrgPerson))}"  #FIXME: check objectclass
				}
			}
			# Finally, if we can't find a matching VLAN ID for the user or client in LDAP, we return the default VLAN ID
			else {
				update reply {
					Reply-Message := "DEBUG: Not found, assigning default VLAN-ID"
					Tunnel-Type := VLAN
					Tunnel-Medium-Type := IEEE-802
					Tunnel-Private-Group-Id := "@%@freeradius/conf/vlan/vlan-id@%@"
				}
			}
		}
	}
	#
	#  When the server decides to proxy a request to a home server,
	#  the proxied request is first passed through the pre-proxy
	#  stage.  This stage can re-write the request, or decide to
	#  cancel the proxy.
	#
	#  Only a few modules currently have this method.
	#
	pre-proxy {
	}
	#
	#  When the server receives a reply to a request it proxied
	#  to a home server, the request may be massaged here, in the
	#  post-proxy stage.
	#
	post-proxy {
		#
		#  If you are proxying LEAP, you MUST configure the EAP
		#  module, and you MUST list it here, in the post-proxy
		#  stage.
		#
		#  You MUST also use the 'nostrip' option in the 'realm'
		#  configuration.  Otherwise, the User-Name attribute
		#  in the proxied request will not match the user name
		#  hidden inside of the EAP packet, and the end server will
		#  reject the EAP request.
		#
		eap
	}
}
