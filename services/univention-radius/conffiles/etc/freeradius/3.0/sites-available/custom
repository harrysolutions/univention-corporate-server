server custom {
	listen {
		type = auth
		ipaddr = *
@!@
print('\t\tport = %s' % (configRegistry.get('freeradius/conf/port', '0'), ))
@!@
		limit {
			#
			#  Limit the number of simultaneous TCP connections to the socket
			#
			#  The default is 16.
			#  Setting this to 0 means "no limit"

			max_connections = 16

			#  The per-socket "max_requests" option does not exist.
			#
			#  The lifetime, in seconds, of a TCP connection.  After
			#  this lifetime, the connection will be closed.
			#
			#  Setting this to 0 means "forever".

			lifetime = 0

			#
			#  The idle timeout, in seconds, of a TCP connection.
			#  If no packets have been received over the connection for
			#  this time, the connection will be closed.
			#
			#  Setting this to 0 means "no timeout".
			#
			#  We STRONGLY RECOMMEND that you set an idle timeout.
			#

			idle_timeout = 30
		}
	}
	listen {
		ipaddr = *
@!@
print('\t\tport = %s' % (configRegistry.get('freeradius/conf/accountingport', '0'), ))
@!@
		type = acct
	}

	# IPv6 versions of the above - read their full config to understand options
	listen {
		type = auth
		ipv6addr = ::	# any.  ::1 == localhost
@!@
print('\t\tport = %s' % (configRegistry.get('freeradius/conf/port', '0'), ))
@!@

		limit {
		      max_connections = 16
		      lifetime = 0
		      idle_timeout = 30
		}
	}

	listen {
		ipv6addr = ::
@!@
print('\t\tport = %s' % (configRegistry.get('freeradius/conf/accountingport', '0'), ))
@!@
		type = acct
	}

	authorize {
		#
		#  Take a User-Name, and perform some checks on it, for spaces and other
		#  invalid characters.  If the User-Name appears invalid, reject the
		#  request.
		#
		#  See policy.d/filter for the definition of the filter_username policy.
		#
		filter_username
		#
		#  The preprocess module takes care of sanitizing some bizarre
		#  attributes in the request, and turning them into attributes
		#  which are more standard.
		#
		#  It takes care of processing the 'raddb/hints' and the
		#  'raddb/huntgroups' files.
		preprocess
	    ## To handle unauthenticated clients based on their MAC address, we check IF we are talking EAP or not:
		if ((!&EAP-Message) && Calling-Station-Id) {
            # Scenario: known client, but client can't be authenticated via EAP + MSCHAPv2 (not joined (yet), PXE-Boot etc.)
            # So we are not talking EAP. Therefore we do check the MAC address and the VLAN-ID
            ## According to RFC 3580 should sanitize the MAC address to "AA-BB-CC-DD-EE-FF"
            ## see https://tools.ietf.org/html/rfc3580 3.20 & 3.21
            ## see also https://wiki.freeradius.org/guide/mac-auth
            ## This can be achieved by using these functions defined in /etc/freeradius/../policy.d/canonicalization:
            ## rewrite_called_station_id   # For the NAS/WLAN-AP
            ## rewrite_calling_station_id  # For the Client
            ## Unfortunately, OpenLDAP stores the macAddress as "aa:bb:cc:dd:ee:ff" (lowercase and ':' instead of '-')
            ## Therefore we adapt 'rewrite_calling_station_id' to fit our needs:
            if (Calling-Station-Id =~ /([0-9a-f]{2})[-:]?([0-9a-f]{2})[-:.]?([0-9a-f]{2})[-:]?([0-9a-f]{2})[-:.]?([0-9a-f]{2})[-:]?([0-9a-f]{2})/i) {
                update request {
                    Calling-Station-Id := "%{tolower:%{1}:%{2}:%{3}:%{4}:%{5}:%{6}}"
                }
            }
            if ("%{ldap:ldap:///@%@ldap/base@%@?cn?sub?(macAddress=%{Calling-Station-Id})}") {
                if ("%{ldap:ldap:///@%@ldap/base@%@?univentionVlanId?sub?(&(memberUid=%{ldap:ldap:///@%@ldap/base@%@?cn?sub?(macAddress=%{Calling-Station-Id})}$)(univentionObjectType=groups/group)(univentionVlanId=*))}") {
                    update control {
                        Auth-Type := Accept
                    }
                    update reply {
                        Reply-Message := "DEBUG: Non-EAP: MAC found, VLAN ID found - sending VLAN-ID from LDAP object"
                        Tunnel-Type := VLAN
                        Tunnel-Medium-Type := IEEE-802
                        Tunnel-Private-Group-Id := "%{ldap:ldap:///@%@ldap/base@%@?univentionVlanId?sub?(&(memberUid=%{ldap:ldap:///@%@ldap/base@%@?cn?sub?(macAddress=%{Calling-Station-Id})}$)(univentionObjectType=groups/group)(univentionVlanId=*))}"
                    }
                }
                 ## If we can only find the macAddress but no VLAN ID, send the client to the default VLAN:
                elsif ("@%@freeradius/vlan-id@%@") {
                    # accept and send default VLAN ID:
                    update control {
                        Auth-Type := Accept
                    }
                    update reply {
                        Reply-Message := "DEBUG: Non-EAP: MAC found, but no VLAN ID - sending default VLAN-ID"
                        Tunnel-Type := VLAN
                        Tunnel-Medium-Type := IEEE-802
                        Tunnel-Private-Group-Id := "@%@freeradius/vlan-id@%@"
                    }
                    return
                }
                ## If we can only find the macAddress but the computer is in no group with VLAN ID, just authentcaite, but set no VLAN-ID
                else {
                    # accept and send default VLAN ID:
                    update control {
                        Auth-Type := Accept
                    }
                    return
                }
            }
		}
		## IF we are talking EAP, follow the default auth config:
		else {
            #
            #  The chap module will set 'Auth-Type := CHAP' if we are
            #  handling a CHAP request and Auth-Type has not already been set
@!@
auth_type = configRegistry.get('freeradius/conf/auth-type/mschap', 'FALSE')

if auth_type and 'TRUE' == auth_type.upper() or 'YES' == auth_type.upper():
	print('\t\tchap')
else:
	print('#\t\tchap')
@!@
            #
            #  If the users are logging in with an MS-CHAP-Challenge
            #  attribute for authentication, the mschap module will find
            #  the MS-CHAP-Challenge attribute, and add 'Auth-Type := MS-CHAP'
            #  to the request, which will cause the server to then use
            #  the mschap module for authentication.
@!@
auth_type = configRegistry.get('freeradius/conf/auth-type/mschap', 'FALSE')

if auth_type and 'TRUE' == auth_type.upper() or 'YES' == auth_type.upper():
	print('\t\tmschap')
else:
	print('#\t\tmschap')
@!@			#
			#  If you are using multiple kinds of realms, you probably
			#  want to set "ignore_null = yes" for all of them.
			#  Otherwise, when the first style of realm doesn't match,
			#  the other styles won't be checked.
			# ntdomain
@!@
print('%s' % configRegistry.get('freeradius/conf/realm', 'suffix'))
@!@
			#
			#  This module takes care of EAP-MD5, EAP-TLS, and EAP-LEAP
			#  authentication.
			#
			#  It also sets the EAP-Type attribute in the request
			#  attribute list to the EAP type from the packet.
			#
			#  As of 2.0, the EAP module returns "ok" in the authorize stage
			#  for TTLS and PEAP.  In 1.x, it never returned "ok" here, so
			#  this change is compatible with older configurations.
			#
			#  The example below uses module failover to avoid querying all
			#  of the following modules if the EAP module returns "ok".
			#  Therefore, your LDAP and/or SQL servers will not be queried
			#  for the many packets that go back and forth to set up TTLS
			#  or PEAP.  The load on those servers will therefore be reduced.
			#
			eap {
				ok = return
			}
			#
			#  Read the 'users' file
@!@
print('%s' % configRegistry.get('freeradius/conf/users', 'files'))
@!@
			#
			#  The ldap module will set Auth-Type to LDAP if it has not
			#  already been set
			ldap
			expiration
			logintime
			#
			#  If no other module has claimed responsibility for
			#  authentication, then try to use PAP.  This allows the
			#  other modules listed above to add a "known good" password
			#  to the request, and to do nothing else.  The PAP module
			#  will then see that password, and use it to do PAP
			#  authentication.
			#
			#  This module should be listed last, so that the other modules
			#  get a chance to set Auth-Type for themselves.
			#
			pap
		}
	}
	#  Authentication.
	#
	#
	#  This section lists which modules are available for authentication.
	#  Note that it does NOT mean 'try each module in order'.  It means
	#  that a module from the 'authorize' section adds a configuration
	#  attribute 'Auth-Type := FOO'.  That authentication type is then
	#  used to pick the apropriate module from the list below.
	#
	#  In general, you SHOULD NOT set the Auth-Type attribute.  The server
	#  will figure it out on its own, and will do the right thing.  The
	#  most common side effect of erroneously setting the Auth-Type
	#  attribute is that one authentication method will work, but the
	#  others will not.
	#
	#  The common reasons to set the Auth-Type attribute by hand
	#  is to either forcibly reject the user (Auth-Type := Reject),
	#  or to or forcibly accept the user (Auth-Type := Accept).
	#
	#  Note that Auth-Type := Accept will NOT work with EAP.
	#
	#  Please do not put "unlang" configurations into the "authenticate"
	#  section.  Put them in the "post-auth" section instead.  That's what
	#  the post-auth section is for.
	#
	authenticate {
		#
		#  PAP authentication, when a back-end database listed
		#  in the 'authorize' section supplies a password.  The
		#  password can be clear-text, or encrypted.
		Auth-Type PAP {
			pap
		}
		#
		#  Most people want CHAP authentication
		#  A back-end database listed in the 'authorize' section
		#  MUST supply a CLEAR TEXT password.  Encrypted passwords
		#  won't work.
@!@
auth_type = configRegistry.get('freeradius/conf/auth-type/mschap', 'FALSE')

if auth_type and 'TRUE' == auth_type.upper() or 'YES' == auth_type.upper():
	print('\t\tAuth-Type CHAP {')
	print('\t\t\tchap')
	print('\t\t}')
else:
	print('#      Auth-Type CHAP {')
	print('#\\ttchap')
	print('#      }')
@!@
	#
	#  MSCHAP authentication.
@!@
auth_type = configRegistry.get('freeradius/conf/auth-type/mschap', 'FALSE')

if auth_type and 'TRUE' == auth_type.upper() or 'YES' == auth_type.upper():
	print('\t\tAuth-Type MS-CHAP {')
	print('\t\t\tmschap')
	print('\t\t}')
else:
	print('#      Auth-Type MS-CHAP {')
	print('#\\ttmschap')
	print('#      }')
@!@
		#
		#  See 'man getpwent' for information on how the 'unix'
		#  module checks the users password.  Note that packets
		#  containing CHAP-Password attributes CANNOT be authenticated
		#  against /etc/passwd!  See the FAQ for details.
		#
		# unix
		# Uncomment it if you want to use ldap for authentication
		#
		# Note that this means "check plain-text password against
		# the ldap database", which means that EAP won't work,
		# as it does not supply a plain-text password.
		Auth-Type LDAP {
			ldap
		}
		#
		#  Allow EAP authentication.
		eap
	}
	#
	#  Pre-accounting.  Decide which accounting type to use.
	#
	preacct {
		preprocess
		#  Ensure that we have a semi-unique identifier for every
		#  request, and many NAS boxes are broken.
		acct_unique
		# Setting suffix as realm default MSCHAP needs ntdomain
        #	ntdomain
@!@
print('%s' % configRegistry.get('freeradius/conf/realm', 'suffix'))
@!@

	    #
	    #  Read the 'acct_users' file
        #	files
@!@
print('%s' % configRegistry.get('freeradius/conf/users', 'files'))
@!@
	}
	#
	#  Accounting.  Log the accounting data.
	#
	accounting {
        #  Update accounting packet by adding the CUI attribute
        #  recorded from the corresponding Access-Accept
        #  use it only if your NAS boxes do not support CUI themselves
    #	cui
        #
        #  Create a 'detail'ed log of the packets.
        #  Note that accounting requests which are proxied
        #  are also logged in the detail file.
        detail
    #	daily

        #  Update the wtmp file
        #
        #  If you don't use "radlast", you can delete this line.
        unix

        #
        #  For Simultaneous-Use tracking.
        #
        #  Due to packet losses in the network, the data here
        #  may be incorrect.  There is little we can do about it.
    #	radutmp
    #	sradutmp

        #  Return an address to the IP Pool when we see a stop record.
    #	main_pool

        #
        #  Log traffic to an SQL database.
        #
        #  See "Accounting queries" in mods-available/sql
        -sql

        #
        #  If you receive stop packets with zero session length,
        #  they will NOT be logged in the database.  The SQL module
        #  will print a message (only in debugging mode), and will
        #  return "noop".
        #
        #  You can ignore these packets by uncommenting the following
        #  three lines.  Otherwise, the server will not respond to the
        #  accounting request, and the NAS will retransmit.
        #
    #	if (noop) {
    #		ok
    #	}

        #
        #  Instead of sending the query to the SQL server,
        #  write it into a log file.
        #
    #	sql_log

        #  Cisco VoIP specific bulk accounting
    #	pgsql-voip

        # For Exec-Program and Exec-Program-Wait
        exec

        #  Filter attributes from the accounting response.
        attr_filter.accounting_response

        #
        #  See "Autz-Type Status-Server" for how this works.
        #
    #	Acct-Type Status-Server {
    #
    #	}
    }

	#  Session database, used for checking Simultaneous-Use. Either the radutmp
	#  or rlm_sql module can handle this.
	#  The rlm_sql module is *much* faster
	session {
	#	radutmp
	#
	#  See "Simultaneous Use Checking Queries" in mods-available/sql
    #	sql
	}

	#  Post-Authentication
	#  Once we KNOW that the user has been authenticated, there are
	#  additional steps we can take.
	post-auth {
		#  For EAP-TTLS and PEAP, add the cached attributes to the reply.
        #  The "session-state" attributes are automatically cached when
        #  an Access-Challenge is sent, and automatically retrieved
        #  when an Access-Request is received.
        #
        #  The session-state attributes are automatically deleted after
        #  an Access-Reject or Access-Accept is sent.
        #
        update {
            &reply: += &session-state:
        }
        #
	    #  After authenticating the user, do another SQL query.
	    #
	    #  See "Authentication Logging Queries" in mods-available/sql
	    -sql

        # For Exec-Program and Exec-Program-Wait
        exec

		# Load module: ldap
		ldap
		# Rewrite username if it is a machine account. The krb5PrincipalName is passed as User-Name in the request in this case.
		if ("%{request:User-Name}" =~ /^host\/(.*).@%@domainname@%@$/) {
			update request {
				User-Name := "%{1}$"    # The uid attribute in the ldap object is filled with the host name and a trailing dollar sign.
			}
		}
		# Check if the user or machine exists and do post-auth actions
		# else do nothing in post-auth
		# This way we also make sure that we do not change the VLAN ID again if the non-EAP-auth (MAC address auth) succeeded before (see above)
		if ("%{ldap:ldap:///@%@ldap/base@%@?uid?sub?(uid=%{User-Name})}") {
			# For known users as well for known machines we take the vlan-id from the group the user/machine is member of.
			# In case there are assignments for several groups the first vlan-id is automatically taken.
			if ("%{ldap:ldap:///@%@ldap/base@%@?univentionVlanId?sub?(&(memberUid=%{User-Name})(univentionObjectType=groups/group)(univentionVlanId=*))}") {
				update reply {
					Reply-Message := "DEBUG: Assigning VLAN-ID from user / computer object"
					Tunnel-Type := VLAN
					Tunnel-Medium-Type := IEEE-802
					Tunnel-Private-Group-Id := "%{ldap:ldap:///@%@ldap/base@%@?univentionVlanId?sub?(&(memberUid=%{User-Name})(univentionObjectType=groups/group)(univentionVlanId=*))}"
				}
			}
			# If we can't find a matching VLAN ID for the user or machine client in LDAP, we return the default VLAN ID, if configured.
			# If no default vlan-id is configured in ucr we do not return any vlan information
			elsif ("@%@freeradius/vlan-id@%@") {
				update reply {
					Reply-Message := "DEBUG: Not found, assigning default VLAN-ID"
					Tunnel-Type := VLAN
					Tunnel-Medium-Type := IEEE-802
					Tunnel-Private-Group-Id := "@%@freeradius/vlan-id@%@"
				}
			}
		}
        #  Remove reply message if the response contains an EAP-Message
        remove_reply_message_if_eap
        Post-Auth-Type REJECT {
            # log failed authentications in SQL, too.
            -sql
            attr_filter.access_reject

            # Insert EAP-Failure message if the request was
            # rejected by policy instead of because of an
            # authentication failure
            eap

            #  Remove reply message if the response contains an EAP-Message
            remove_reply_message_if_eap
        }
	}
	#
	#  When the server decides to proxy a request to a home server,
	#  the proxied request is first passed through the pre-proxy
	#  stage.  This stage can re-write the request, or decide to
	#  cancel the proxy.
	#
	#  Only a few modules currently have this method.
	#
	pre-proxy {
	}
	#
	#  When the server receives a reply to a request it proxied
	#  to a home server, the request may be massaged here, in the
	#  post-proxy stage.
	#
	post-proxy {
		#
		#  If you are proxying LEAP, you MUST configure the EAP
		#  module, and you MUST list it here, in the post-proxy
		#  stage.
		#
		#  You MUST also use the 'nostrip' option in the 'realm'
		#  configuration.  Otherwise, the User-Name attribute
		#  in the proxied request will not match the user name
		#  hidden inside of the EAP packet, and the end server will
		#  reject the EAP request.
		#
		eap
	}
}
